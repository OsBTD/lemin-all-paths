10
##start
start 1 6
0 4 8
o 6 8
n 6 6
e 8 4
t 1 9
E 5 9
a 8 9
m 8 6
h 4 6
A 5 2
c 8 1
k 11 2
##end
end 11 6
start-t
n-e
a-m
A-c
0-o
E-a
k-end
start-h
o-n
m-end
t-E
start-0
h-A
e-end
c-k
n-m
h-n



//////////////////////////
package main

import (
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

type farm struct {
	ants_number int
	rooms       map[string][]int
	start       map[string][]int
	end         map[string][]int
	links       map[string][]string
}

func main() {
	var myFarm farm
	myFarm.Read("test.txt")
	fmt.Printf("\nall sorted paths from start to end: %v\n", BFS(myFarm))
	fmt.Println("Place all Ants on there path: ", Ants(myFarm, BFS(myFarm)))
	MoveAnts(Ants(myFarm, BFS(myFarm)))

	// fmt.Println(Ants(myFarm, BFS(myFarm)))
	// fmt.Println("number of ants is : ", myFarm.ants_number)
	// fmt.Println("rooms are : ", myFarm.rooms)
	// fmt.Println("start is : ", myFarm.start)
	// fmt.Println("end is : ", myFarm.end)
	// fmt.Println("links are : ", myFarm.links)
	// fmt.Println("adjacent is : ", Graph(myFarm))
}

func (myFarm *farm) Read(filename string) {
	bytes, err := os.ReadFile(filename)
	if err != nil {
		log.Println("error reading", err)
	}
	content := strings.Split(string(bytes), "\n")

	myFarm.rooms = make(map[string][]int)
	myFarm.start = make(map[string][]int)
	myFarm.end = make(map[string][]int)
	myFarm.links = make(map[string][]string)

	var st, en int
	number, err := strconv.Atoi(content[0])
	if err != nil {
		log.Println("couldn't convert", err)
	}
	myFarm.ants_number = number

	for index := range content {
		if strings.TrimSpace(content[index]) == "##start" {
			st++
			if index+1 <= len(content)-1 {
				split := strings.Split(strings.TrimSpace(content[index+1]), " ")
				x, err := strconv.Atoi(split[1])
				y, err2 := strconv.Atoi(split[2])
				if err == nil && err2 == nil {
					myFarm.start[split[0]] = []int{x, y}
				}

			}

		} else if strings.TrimSpace(content[index]) == "##end" {
			en++
			if index+1 <= len(content)-1 {
				split := strings.Split(strings.TrimSpace(content[index+1]), " ")
				x, err := strconv.Atoi(split[1])
				y, err2 := strconv.Atoi(split[2])
				if err == nil && err2 == nil {
					myFarm.end[split[0]] = []int{x, y}
				}

			}
		} else if strings.Contains(content[index], "-") {
			split := strings.Split(strings.TrimSpace(content[index]), "-")
			if len(split) == 2 {
				myFarm.links[split[0]] = append(myFarm.links[split[0]], split[1])
			}
		} else if strings.Count(content[index], " ") == 2 {
			split := strings.Split(strings.TrimSpace(content[index]), " ")
			if len(split) == 3 {
				x, err := strconv.Atoi(split[1])
				y, err2 := strconv.Atoi(split[2])
				if err == nil || err2 == nil {
					myFarm.rooms[split[0]] = []int{x, y}
				}
			}
		} else if (strings.HasPrefix(strings.TrimSpace(content[index]), "#") || strings.HasPrefix(strings.TrimSpace(content[index]), "L")) && (strings.TrimSpace(content[index]) != "##start" && strings.TrimSpace(content[index]) != "##end") {
			continue
		}
	}
	if en != 1 || st != 1 {
		log.Println("rooms setup is incorrect", err)
	}
}

func Graph(farm farm) map[string][]string {
	adjacent := make(map[string][]string)
	for room := range farm.rooms {
		adjacent[room] = []string{}
	}
	for room, links := range farm.links {
		for _, link := range links {
			adjacent[room] = append(adjacent[room], link)
			adjacent[link] = append(adjacent[link], room)

		}
	}

	return adjacent
}

func BFS(myFarm farm) [][]string {
	adjacent := Graph(myFarm)
	var Queue []string
	var endd string
	start := myFarm.start
	end := myFarm.end
	var Sorted [][]string

	for key := range start {
		for _, adj := range adjacent[key] {
			Visited := make(map[string]bool)
			Parents := make(map[string]string)

			Queue = append(Queue, adj)
			Visited[adj] = true
			for key := range end {
				endd = key
			}

			for len(Queue) > 0 {
				current := Queue[0]
				Queue = Queue[1:]
				if current == endd {
					Queue = []string{}
					break
				}

				for _, link := range adjacent[current] {
					if !Visited[link] {
						Queue = append(Queue, link)
						Visited[link] = true
						Parents[link] = current
					}
				}
			}

			if !Visited[endd] {
				fmt.Printf("\n No path found to end room \n")
				return [][]string{}
			}

			path := []string{endd}
			current := endd

			for Parents[current] != "" {
				current = Parents[current]
				path = append([]string{current}, path...)
			}
			path = append([]string{key}, path...)
			Sorted = append(Sorted, path)
		}
	}
	Sorted = SortPath(Sorted)
	// fmt.Printf("\nall sorted paths from start to end: %v\n", Sorted)
	return Sorted
}

func SortPath(Paths [][]string) [][]string {
	if len(Paths) <= 1 {
		return Paths
	}
	pivot := Paths[len(Paths)-1]
	var less, greater [][]string
	for _, v := range Paths[:len(Paths)-1] {
		if len(v) <= len(pivot) {
			less = append(less, v)
		} else {
			greater = append(greater, v)
		}
	}
	return append(append(SortPath(less), pivot), SortPath(greater)...)
}

func Ants(myFarm farm, paths [][]string) [][]string {
	ants := myFarm.ants_number

	fmt.Println("num of ants is :", ants)

	k := 0
	for i := ants; i > 0; i-- {
		for j := 0; j < len(paths); j++ {
			if k < len(paths) {
				if len(paths[k]) >= len(paths[j]) {
					paths[k] = append(paths[k], "L"+strconv.Itoa(i))
					break
				}
			} else {
				k = 0
				if len(paths[k]) >= len(paths[j]) {
					paths[k] = append(paths[k], "L"+strconv.Itoa(i))
					break
				}
			}
		}
		k++
	}

	return paths
}

func MoveAnts(paths [][]string) {
	var p, a, text []string
	for i := 0; i < len(paths); i++ {
		for j := 1; j < len(paths[i]); j++ {
			if strings.HasPrefix(paths[i][j], "L") {
				a = append(a, paths[i][j])
			} else {
				p = append(p, paths[i][j])
			}
		}
		for l := 0; l < len(a); l++ {
			for x := 0; x < len(p); x++ {
				text = append(text, a[l]+"-"+p[x]+" ")
			}
		}
		// for l := 0; l < len(a); l++ {
		// 	for k := 0; k < len(p); k++ {
		// 		fmt.Println(a[l] + "-" + p[k])
		// 		continue
		// 	}
		// }
		fmt.Println("\nwhole text is :", text)
		a = []string{}
		p = []string{}
		text = []string{}

	}
}
///////////////////
